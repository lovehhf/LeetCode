# -*- coding:utf-8 -*-

__author__ = 'huanghf'

"""
给定范围 [m, n]，其中 0 <= m <= n <= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。

示例 1: 

输入: [5,7]
输出: 4
示例 2:

输入: [0,1]
输出: 0
(位运算特性) O(31)O(31)
求出m和n从高位到低位中第一次出现不一样的位置，即可得到答案，答案为该位置之前的二进制的累积和。
解释
因为出现了第一次不一样之后，从m上升到n的过程中，必定会经历xxx100000...和xxx011111...的一次变化，这次变化会将该位之后的所有数字按位和清零。

"""


class Solution:
    def rangeBitwiseAnd(self, m: int, n: int) -> int:
        """
        这个题精髓在于n的二进制位比m二进制最左边的1高时，&的结果必然为0；
        由这个思想启发，二进制最高位相同时，这个1会保存，然后比较右一位，相同也保留... 所以只需要m n 同时右移到相等时 m n的值就是&后能保留的位数，然后左移回来就是最后的值。
        :param m: 
        :param n: 
        :return: 
        """

        res = 0

        for i in range(30, -1, -1):
            a = 1 << (i + 1)  # 上边界
            b = 1 << i  # 下边界
            if b <= m < a and b <= n < a:
                res += b
                m -= b
                n -= b

        return res


m, n = 20000, 2147483647
s = Solution()
print(s.rangeBitwiseAnd(m, n))
