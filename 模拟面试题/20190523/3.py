# -*- coding:utf-8 -*-

__author__ = 'huanghf'

"""
给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。

如果数组元素个数小于 2，则返回 0。

示例 1:

输入: [3,6,9,1]
输出: 3
解释: 排序后的数组是 [1,3,6,9], 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。
示例 2:

输入: [10]
输出: 0
解释: 数组元素个数小于 2，因此返回 0。
说明:

你可以假设数组中所有元素都是非负整数，且数值在 32 位有符号整数范围内。
请尝试在线性时间复杂度和空间复杂度的条件下解决此问题。


桶排序 https://www.jianshu.com/p/e6837a40bc30

1.利用桶排序的思想，先求出原数组从最小值Min到最大值Max的单位区间长度d，d=(Max-Min)/n。算出d的作用是为了后续确定各个桶的区间范围划分。
2.创建一个长度是N+1的数组Array，数组的每一个元素都是一个List，代表一个桶。
3.遍历原数组，把原数组每一个元素插入到新数组Array对应的桶当中，进入各个桶的条件是根据不同的数值区间（数值区间如何划分，看后面的图就明白了）。由于桶的总数量是N+1，所以至少有一个桶是空的。
4.遍历新数组Array，计算每一个空桶右端非空桶中的最小值，与空桶左端非空桶的最大值的差，数值最大的差即为原数组排序后的相邻最大差值。


"""


class Solution(object):
    def maximumGap(self, nums):
        """
        时间复杂度O(NlogN)
        :type nums: List[int]
        :rtype: int
        """
        nums.sort()
        res = max([nums[i] - nums[i - 1] for i in range(1, len(nums))]) if len(nums) > 1 else 0
        return res
